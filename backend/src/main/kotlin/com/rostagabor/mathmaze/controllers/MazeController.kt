package com.rostagabor.mathmaze.controllers

import com.beust.klaxon.JsonObject
import com.rostagabor.mathmaze.requests.MazeCheckRequest
import com.rostagabor.mathmaze.requests.MazeGenerationRequest
import com.rostagabor.mathmaze.requests.MazeSaveRequest
import com.rostagabor.mathmaze.services.MazeService
import com.rostagabor.mathmaze.services.UserService
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.multipart.MultipartFile

/**
 *   Controller for maze-related tasks.
 */
@RestController
@RequestMapping("/maze")
class MazeController(
    private val userService: UserService,
    private val mazeService: MazeService,
) {

    /**
     *   Generates a maze.
     */
    @PostMapping("/generate")
    fun generate(@RequestBody mazeGenerationRequest: MazeGenerationRequest): ResponseEntity<Any> {
        return try {
            val (_, token) = userService.regenerateTokenIfStillValid(mazeGenerationRequest.token)

            val maze = mazeService.generateMaze(
                mazeGenerationRequest.width,
                mazeGenerationRequest.height,
                mazeGenerationRequest.numbersRangeStart,
                mazeGenerationRequest.numbersRangeEnd,
                mazeGenerationRequest.operation,
                mazeGenerationRequest.pathTypeEven,
                mazeGenerationRequest.minLength,
                mazeGenerationRequest.maxLength,
                mazeGenerationRequest.discardedMazes,
            )
            ResponseEntity.ok().body(
                JsonObject().apply {
                    this["maze"] = maze
                    this["token"] = token
                }
            )
        } catch (e: Exception) {
            ResponseEntity.badRequest().body(e::class.simpleName)
        }
    }


    /**
     *   Saves a maze.
     */
    @PostMapping("/save")
    fun save(@RequestBody mazeSaveRequest: MazeSaveRequest): ResponseEntity<Any> {
        return try {
            val (email, token) = userService.regenerateTokenIfStillValid(mazeSaveRequest.token)

            val maze = mazeService.saveMaze(email, mazeSaveRequest.mazeId)
            ResponseEntity.ok().body(
                JsonObject().apply {
                    this["maze"] = maze
                    this["token"] = token
                }
            )
        } catch (e: Exception) {
            ResponseEntity.badRequest().body(e::class.simpleName)
        }
    }


    /**
     *   Recognises a maze in an image.
     */
    @PostMapping("/recognise", consumes = ["multipart/form-data"])
    fun recognise(
        @RequestParam("mazeId") mazeId: Long,
        @RequestParam("image") image: MultipartFile,
        @RequestParam("rotation") rotation: Int,
        @RequestParam("token") token: String?,
    ): ResponseEntity<Any> {
        return try {
            val (_, newToken) = userService.regenerateTokenIfStillValid(token)

            val recognisedMaze = mazeService.recogniseMaze(mazeId, image, rotation)
            ResponseEntity.ok().body(
                JsonObject().apply {
                    this["recognisedMaze"] = recognisedMaze
                    this["token"] = newToken
                }
            )
        } catch (e: Exception) {
            ResponseEntity.badRequest().body(e::class.simpleName)
        }
    }


    /**
     *   Checks a maze.
     */
    @PostMapping("/check")
    fun check(@RequestBody mazeCheckRequest: MazeCheckRequest): ResponseEntity<Any> {
        return try {
            val (email, token) = userService.regenerateTokenIfStillValid(mazeCheckRequest.token)

            val maze = mazeService.checkMaze(mazeCheckRequest.mazeId, mazeCheckRequest.data, mazeCheckRequest.path, mazeCheckRequest.nickname, email)
            ResponseEntity.ok().body(
                JsonObject().apply {
                    this["checkedMaze"] = maze
                    this["token"] = token
                }
            )
        } catch (e: Exception) {
            ResponseEntity.badRequest().body(e::class.simpleName)
        }
    }


    /**
     *   Retrieves all mazes generated by the user.
     */
    @GetMapping("/getAll")
    fun getAll(@RequestParam token: String): ResponseEntity<Any> {
        return try {
            val (email, newToken) = userService.regenerateTokenIfStillValid(token)
            val mazes = mazeService.getAllMazes(email)

            ResponseEntity.ok().body(
                JsonObject().apply {
                    this["mazes"] = mazes
                    this["token"] = newToken
                }
            )
        } catch (e: Exception) {
            ResponseEntity.badRequest().body(e::class.simpleName)
        }
    }

}
